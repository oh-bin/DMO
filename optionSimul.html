<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>바이탈 브레스 디지바이스 V — 잠금/기대값 계산기</title>
<style>
  body { font-family: Arial, Helvetica, sans-serif; background:#071126; color:#e6f0ff; padding:20px; }
  .container { max-width:1000px; margin:0 auto; background:#0f1f33; padding:18px; border-radius:12px; box-shadow:0 6px 24px rgba(0,0,0,0.6); }
  h1 { color:#7ddcff; margin-bottom:6px; }
  .top-images { display:flex; gap:10px; margin-bottom:12px; }
  img.example { width:120px; height:120px; object-fit:cover; border-radius:8px; border:1px solid rgba(255,255,255,0.06); }

  .row { display:flex; gap:12px; align-items:center; margin-bottom:10px; }
  .col { flex:1; }

  button.primary { background:#2f6ff7; color:white; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; }
  button.secondary { background:#1e293b; color:#cfe3ff; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; }

  table { width:100%; border-collapse:collapse; margin-top:10px; }
  th, td { border:1px solid rgba(255,255,255,0.06); padding:8px; text-align:center; }
  th { background:rgba(255,255,255,0.03); color:#cfe3ff; }

  .slot-lock { display:flex; gap:6px; justify-content:center; align-items:center; }
  .lock-btn { background:#fbbf24; color:#0b1220; padding:6px 8px; border-radius:6px; cursor:pointer; border:none; }
  .locked { background:#fb7185 !important; color:white; }

  .controls { display:flex; gap:8px; margin-top:12px; flex-wrap:wrap; }
  .note { color:#9fb0d6; font-size:13px; margin-top:12px; }

  .results { margin-top:14px; padding:12px; background:rgba(255,255,255,0.03); border-radius:8px; }
  .results p { margin:6px 0; }

  /* 원하는 옵션 UI 세로로 */
  #desiredContainer { display:flex; flex-direction: column; gap:8px; }
</style>
</head>
<body>
<div class="container">
  <h1>바이탈 브레스 디지바이스 V — 옵션 잠금 & 기대값 계산기</h1>

  <div class="top-images">
    <img class="example" src="/mnt/data/BFC476BF-6152-4F44-BB29-065C8BCBC8B8.png" alt="example1">
    <img class="example" src="/mnt/data/7B7DE10B-0F4E-490C-8498-59CFD9DFCE84.png" alt="example2">
  </div>

  <div class="row">
    <div class="col">
      <button class="primary" onclick="rerollUnlocked()">옵션(비잠금) 리롤</button>
      <button class="secondary" onclick="resetAll()">모두 초기화</button>
    </div>
  </div>

  <!-- 현재 슬롯 표시 및 잠금 토글 -->
  <table>
    <thead>
      <tr><th>슬롯</th><th>현재 옵션</th><th>잠금 토글</th></tr>
    </thead>
    <tbody id="slotsTbody"></tbody>
  </table>

  <hr style="margin:14px 0; border-color:rgba(255,255,255,0.04)">

  <!-- 기대값 계산용 -->
  <h3>원하는 옵션 & 잠금 선택 (최대 2개 잠금)</h3>
  <div id="desiredContainer"></div>

  <div class="controls">
    <button class="primary" onclick="computeExpectation()">기대 옵션 변경 스톤 계산</button>
    <button class="secondary" onclick="fillDesiredWithCurrent()">현재 슬롯값 복사</button>
  </div>

  <div class="results" id="resultBox">
    <p>설명: 슬롯을 잠그면 그 슬롯은 기대값 계산 시 고정됩니다. 원하는 옵션 5개를 입력 후 계산하세요.</p>
  </div>

  <div class="note">
    * 옵션 항목별 최대 등장 허용 수가 있습니다 (예: 공격력 최대 2개 등).<br>
    * 잠금 수에 따라 1회 스톤 소모: 0잠금=1, 1잠금=3, 2잠금=5.
  </div>
</div>

<script>
// ===== 옵션/제한 정의 =====
const OPTION_LIMITS = {
  "공격력": 2, "방어력": 2, "최대체력": 2, "디지소울": 2,
  "스킬피해": 2, "크리티컬": 2, "치명피해": 2, "회피": 2, "적중도": 2,
  "방어력%": 1, "최대 DS 증가%": 1, "최대 HP 증가%": 1,
  "스킬 데미지 증가%": 1, "최종 데미지 증가%": 1
};
const OPTION_NAMES = Object.keys(OPTION_LIMITS);

// 현재 슬롯 상태
let slots = [
  {value:"", locked:false},
  {value:"", locked:false},
  {value:"", locked:false},
  {value:"", locked:false},
  {value:"", locked:false}
];

// 스톤 per try
function stonePerTry(lockCount) {
  if (lockCount === 0) return 1;
  if (lockCount === 1) return 3;
  return 5;
}

// 풀 구성
function buildPool(excludeUsed=[]) {
  const pool = [];
  const used = {};
  excludeUsed.forEach(v => { if (v) used[v] = (used[v]||0)+1; });
  for (const name of OPTION_NAMES){
    const allowed = OPTION_LIMITS[name];
    const remaining = Math.max(allowed - (used[name]||0), 0);
    for (let i=0;i<remaining;i++) pool.push(name);
  }
  return pool;
}

// shuffle
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr;}

// 초기 슬롯 채우기
function fillInitial(){
  const pool = shuffle(buildPool([]));
  for(let i=0;i<5;i++){
    slots[i].value = pool.length? pool.shift():"";
    slots[i].locked=false;
  }
  renderSlots();
}

// 슬롯 렌더
function renderSlots(){
  const tbody = document.getElementById("slotsTbody");
  tbody.innerHTML="";
  for(let i=0;i<5;i++){
    const tr=document.createElement("tr");
    const tdIndex=document.createElement("td"); tdIndex.innerText=`${i+1}번`;
    const tdValue=document.createElement("td"); 
    tdValue.innerText=slots[i].value||"-";
    tdValue.style.fontWeight = slots[i].locked?"700":"400";
    tdValue.style.color = slots[i].locked?"#ffd7d7":"";
    const tdLock=document.createElement("td");
    const btn=document.createElement("button");
    btn.className="lock-btn";
    btn.innerText=slots[i].locked?"잠금 해제":"잠금";
    if(slots[i].locked) btn.classList.add("locked");
    btn.onclick = ()=>{
      const currentLockCount = slots.filter(s=>s.locked).length;
      if(!slots[i].locked && currentLockCount>=2){ alert("최대 2개까지만 잠글 수 있습니다."); return; }
      slots[i].locked = !slots[i].locked;
      renderSlots();
    };
    tdLock.appendChild(btn);
    tr.appendChild(tdIndex); tr.appendChild(tdValue); tr.appendChild(tdLock);
    tbody.appendChild(tr);
  }
}

// 비잠금 슬롯 리롤
function rerollUnlocked(){
  const lockedValues = slots.filter(s=>s.locked).map(s=>s.value).filter(Boolean);
  let pool = shuffle(buildPool(lockedValues));
  for(let i=0;i<5;i++){ if(slots[i].locked) continue; slots[i].value=pool.length?pool.shift():""; }
  renderSlots();
}

// 완전 초기화
function resetAll(){ fillInitial(); }

// 원하는 옵션 UI
function renderDesiredUI(){
  const cont=document.getElementById("desiredContainer");
  cont.innerHTML="";
  for(let i=0;i<5;i++){
    const row = document.createElement("div");
    row.style.display="flex"; row.style.alignItems="center"; row.style.gap="6px";

    const sel=document.createElement("select");
    sel.dataset.slot=i;
    sel.style.flex="1"; sel.style.padding="6px"; sel.style.borderRadius="6px"; sel.style.background="#0b1220"; sel.style.color="#e6f0ff"; sel.style.border="1px solid rgba(255,255,255,0.06)";
    const empty = document.createElement("option"); empty.value=""; empty.innerText=`원하는 옵션 ${i+1}`; sel.appendChild(empty);
    OPTION_NAMES.forEach(name=>{ const o=document.createElement("option"); o.value=name; o.innerText=name; sel.appendChild(o); });

    const chk=document.createElement("input"); chk.type="checkbox"; chk.dataset.slot=i;
    chk.addEventListener('change', ()=>{
      const selected = Array.from(document.querySelectorAll("#desiredContainer input[type=checkbox]")).filter(c=>c.checked);
      if(selected.length>2){ chk.checked=false; alert("최대 2개까지만 잠글 수 있습니다."); }
    });

    row.appendChild(sel); row.appendChild(chk);
    cont.appendChild(row);
  }
}

// 복사: 현재 슬롯값 -> 원하는 옵션
function fillDesiredWithCurrent(){
  const selects=document.querySelectorAll("#desiredContainer select");
  selects.forEach((s,i)=> s.value=slots[i].value||"");
}

// 단일 시도 성공확률 계산 (순서 상관없음)
function computeSingleTrialProb(desiredArr, lockArr){
  // locked check
  for(let i=0;i<5;i++){ if(lockArr[i] && slots[i].value!==desiredArr[i]) return 0; }
  const lockedValues = [];
  lockArr.forEach((l,i)=>{ if(l && desiredArr[i]) lockedValues.push(desiredArr[i]); });
  const pool = buildPool(lockedValues);
  const counts={};
  pool.forEach(x=>counts[x]=(counts[x]||0)+1);
  let N=pool.length;
  let p=1;
  for(let i=0;i<5;i++){
    if(lockArr[i]) continue;
    const desired=desiredArr[i];
    const avail=counts[desired]||0;
    if(avail<=0) return 0;
    p*=avail/N; counts[desired]=avail-1; N-=1;
  }
  return p;
}

// 기대값 계산
function computeExpectation(){
  const selects=document.querySelectorAll("#desiredContainer select");
  const checkboxes=document.querySelectorAll("#desiredContainer input[type=checkbox]");
  const desired=Array.from(selects).map(s=>s.value);
  const lockArr=Array.from(checkboxes).map(c=>c.checked);

  if(desired.some(v=>v==="")){ alert("원하는 옵션 5개를 모두 선택해주세요."); return; }
  const lockCount=lockArr.filter(Boolean).length;
  const p=computeSingleTrialProb(desired, lockArr);
  const perTryStone=stonePerTry(lockCount);
  const resultBox=document.getElementById("resultBox");

  if(p===0){ resultBox.innerHTML="<p><strong>결과:</strong> 잠금된 슬롯과 원하는 옵션이 맞지 않아 불가능합니다.</p>"; return; }
  const expectedTrials=1/p;
  const expectedStones=expectedTrials*perTryStone;
  function fmtPct(x){ return (x*100).toFixed(6)+"%"; }
  function fmtNum(x){ return x>=1e6? Math.round(x).toLocaleString():Number(x.toFixed(2)).toLocaleString(); }

  resultBox.innerHTML=`
    <p><strong>잠금 수:</strong> ${lockCount}개</p>
    <p><strong>단일 시도 성공 확률:</strong> ${fmtPct(p)}</p>
    <p><strong>기대 시도 횟수 (평균):</strong> ${fmtNum(expectedTrials)}</p>
    <p><strong>1회 스톤 소모량:</strong> ${perTryStone}개</p>
    <p><strong>기대 옵션 변경 스톤 (평균):</strong> ${fmtNum(expectedStones)}개</p>
    <hr>
    <p style="color:#cfe3ff"><em>참고:</em> 순서 상관없이 옵션만 맞으면 성공 확률 계산.</p>
  `;
}

// 초기화
function init(){ renderDesiredUI(); fillInitial(); }

// expose
window.rerollUnlocked=rerollUnlocked;
window.resetAll=resetAll;
window.fillDesiredWithCurrent=fillDesiredWithCurrent;
window.computeExpectation=computeExpectation;

init();
</script>
</body>
</html>
